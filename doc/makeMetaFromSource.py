"""Parse a .py file to extract tags to generate a widget meta file.

Tags are as follows:
~~~~~~~~~~~~~~~~~~~~

#. ``:Name:, The name of the widget``
#. ``:Icon:, The icon file for this widget.  Must appear in the icons dir.``
#. ``:Authors:, Comma delimited list of authors and contact info.  In the form: Kyle R. Covington (kyle@red-r.org), ...``
#. ``:Summary:, A brief summary of the widget.``
#. ``:Details:, A longer description of the widget.``

Several new "directives" are defined as follows:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. ``.. rrvnames::, Either a blank line, in which case the R variable names come from the .py file, or a tagged list of name descriptor pairs in the form: :name: varName :description: varName generated by a call to makeVarName.``
#. ``.. signals::, Either a blank line, in which case the signals are taken from the .py file, or a taggel list of the signal names and classes in the form: :name: Signal name :class: package.signalClass```
#. ``.. rrgui::, Either a blank line, in which case the GUI parameters are taken from the .py file, or a tagged entry of the class, label and description in the form: :class: package.qtWidget, :label: Label name, :description: This is a gui entry that should be used for something.``

"""

import re
inDocString = False


def _getRSTDirective(string):
    """Returns an rst directive or None in the form \.\.\ (?P<directive>.*?)::"""
    match = re.search('\.\.\ (?P<directive>.*?)::', string)
    if not match: return None
    else: return match.groupdict()['directive']

def _getRSTTag(string):
    """Returns a tag name and value depending on if the string contains any strings of the form :(?P<tag>.*?): (?P<value>.*)(\"\"\")|$ """
    matches = {}
    for m in re.finditer(':(?P<tag>.*?): (?P<value>.*)', string):
        matches[m.groupdict()['tag']] = m.groupdict()['value']
  
def _getRvariableNames(string):
    """Matches the names of R variables in the setRvariableNames declaration.  Returns a a list of names"""
    match = re.findall('[\"\'](?P<tag>.*?)[\"\']', string)
    return match

def _getRRSignals(string):
    """Parses from a call to addOutput or addInput the name and class(s) of an input or output signal, returns a tuple of signaltype [input/output], name, and signal class(s) or returns None if no match found (the end of the signals directive)"""
    if re.search('self\.inputs\.addInput', string) != None:
        call = re.search('\((?P<tag>.*)\)\ *$', string).group()
        return ('input', call.split(',')[1].strip('\'\"()_'), call.split(',')[2])
    elif re.serach('self\.outputs\.addOutput', string) != None:
        call = re.search('\((?P<tag>.*)\)\ *$', string).group()
        return ('output', call.split(',')[1].strip('\'\"()_'), call.split(',')[2])
    else: return None

def _getRRGUISettings(string):
    """Parses an rrgui setting and returns a tuple of class, label or None"""
    match = re.match('redRGUI\.(?P<class>.*?)\(.*?label\ ?=[\ _\(]*[\'\"](?P<label>.*?)[\'\"]\)?,', string)
    if match == None:
        reutrn None
    else:
        d = match.groupdict()
        return (d['class'], d['label'])
     
            

def _parsefile(myFile, doc):
    rVarNames = []
    signals = []
    rrgui = []
    for m in  re.finditer(re.compile(r'"""(?P<docstring>.+?)""" *\n(?P<next>.*?)\n *\n', re.DOTALL | re.MULTILINE), myFile):
        gDict = m.groupdict()
        """if the gDict contains a directiv we should find out what the directive is and then how to handle it."""
        if _getRSTDirective(gDict['docstring']) != None:
            directive = _getRSTDirective(gDict['docstring'])
            if directive in ['rrvnames', 'signals', 'rrgui']:  # it's one of ours!!
                """if there are other options in the docstring then they belong to this directive, we try to get them"""
                tags = _getRSTTag(gDict['docstring'])
                if len(tags.values()) == 0: ## there were no tags returned, we have to take the data from the 'next' tag.
                    if directive == 'rrvnames':
                        rVarNames.append(_getRvariableNames(gDict['next']))
                    elif directive == 'signals':
                        for s in gDict['next'].split(r'\n'):
                            signals.append(_getRRSignals(s))
                    elif directive == 'rrgui':
                        rrgui.append(_getRRGUISettings(gDict['next']))
                else: # the docstring has some tags in it so we use those
                    if directive == 'rrvnames':
                        rVarNames.append(tags['names']
                        
        

def parseFile(filename, output):
    """Reads a file and parses out the relevant widget xml settings, writes to the file output an xml document representing the parsed data.  Prints success message on success."""
    fileStrings = []
    with open(filename, 'r') as f:
        myFile = f.read()

    """Pass the list of strings to the parser to extract the relevant structure"""
    import xml.dom.minidom
    doc = xml.dom.minidom.Document()
    _parsefile(myFile, doc)
    with open(output, 'w') as f:
        f.write(doc.toprettyxml)
    print 'Success for %s' % filename