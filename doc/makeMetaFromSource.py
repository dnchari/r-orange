"""Parse a .py file to extract tags to generate a widget meta file.

Tags are as follows:
~~~~~~~~~~~~~~~~~~~~

#. ``:Name:, The name of the widget``
#. ``:Icon:, The icon file for this widget.  Must appear in the icons dir.``
#. ``:Authors:, Comma delimited list of authors and contact info.  In the form: Kyle R. Covington (kyle@red-r.org), ...``
#. ``:Summary:, A brief summary of the widget.``
#. ``:Details:, A longer description of the widget.``

Several new "directives" are defined as follows:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. ``.. rrvnames::, Either a blank line, in which case the R variable names come from the .py file, or a tagged list of name descriptor pairs in the form: :name: varName :description: varName generated by a call to makeVarName.``
#. ``.. signals::, Either a blank line, in which case the signals are taken from the .py file, or a taggel list of the signal names and classes in the form: :name: Signal name :class: package.signalClass```
#. ``.. rrgui::, Either a blank line, in which case the GUI parameters are taken from the .py file, or a tagged entry of the class, label and description in the form: :class: package.qtWidget, :label: Label name, :description: This is a gui entry that should be used for something.``

"""

import re
inDocString = False


def _getRSTDirective(string):
    """Returns an rst directive or None in the form \.\.\ (?P<directive>.*?)::"""
    match = re.search('\.\.\ (?P<directive>.*?)::', string)
    if not match: return None
    else: return match.groupdict()['directive']

def _getRSTTag(string):
    """Returns a tag name and value depending on if the string contains any strings of the form :(?P<tag>.*?): (?P<value>.*)(\"\"\")|$ """
    matches = {}
    for m in re.finditer(re.compile(r'\s:(?P<tag>.+?): `(?P<value>.+?)`', re.DOTALL), string):
        #print m.groupdict()
        if m.groupdict()['tag'] != None and m.groupdict()['value'] != None:
            matches[m.groupdict()['tag']] = m.groupdict()['value']
        #print 'Parsed string to return these tags %s' % matches
    return matches
    
def _getRvariableNames(string):
    """Matches the names of R variables in the setRvariableNames declaration.  Returns a a list of names"""
    #print 'R Var names string %s' % string
    match = re.search(r'self\.setRvariableNames\((?P<names>.*)\)', string)
    if match:
        match = match.group().split(',')
        return [{'name':m.replace('\'', '').replace('"', ''), 'description':''} for m in match]
    else: return None

def _getRRSignals(string):
    """Parses from a call to addOutput or addInput the name and class(s) of an input or output signal, returns a tuple of signaltype [input/output], name, and """
    print string
    match = re.search(re.compile(r"""self\.(?P<type>.*?)s\.add.*?\(['"](?P<id>.*?)['"].*?['"](?P<name>.*?)['"]""", re.DOTALL), string) # *?signals\.(?P<description>.*?)[,\)$]
    if match:
        dic = match.groupdict()
        cla = re.search(re.compile(r"""signals\.(?P<class>.+?)[,\)\s]""",re.DOTALL), string)
        if cla:
            dic.update(cla.groupdict())
        print string
        desc = _getRSTTag(string)
        if desc:
            dic.update(desc.groupdict())
        else:
            dic.update({'description':''})
        if dic['description'] == None: dic['description'] = ''
        #print dic
        return dic
    else: return None

def _getRRGUISettings(string):
    """Parses an rrgui setting and returns a tuple of class, label or None"""
    match = re.search(re.compile('redRGUI\.(?P<class>.*?)\(.*?label *= *(_\()?[\\\'\\\"](?P<label>.*?)[\\\'\\\"](\))?', re.DOTALL), string)
    if not match: return None
    d = match.groupdict()
    disc = re.search(re.compile('.*toolTip *= *(_\()?[\\\'\\\"](?P<description>.*?)[\\\'\\\"]', re.DOTALL), string)
    if disc:
        d.update(disc.groupdict())
    else:
        d['description'] = ''
    if d['description'] == None: d['description'] = ''
    return d
     
            

def _parsefile(myFile, doc):
    rVarNames = []
    signals = []
    rrgui = []
    optionTags = {}
    for m in  re.finditer(re.compile(r'(?P<spacestring>.*?)(\n\s*\n)', re.DOTALL | re.MULTILINE), myFile.replace('\r', '')):
        """ m is a spacestring so m is any set separated by a whitespace line.  Data is processed in blocks of these."""
        #print m.groupdict()
        if not re.search(re.compile(r'""".*"""', re.DOTALL), m.group()): continue #"""There are no strings to process.  Note that the docstring must be the 
        if not re.search(re.compile(r'\s*"""', re.DOTALL), m.group().split('\n')[0]): continue # """The docstring must be at the beginning of the block"""
        
        gDict = m.group()
        """if the gDict contains a directiv we should find out what the directive is and then how to handle it."""
        if _getRSTDirective(gDict) != None:
            
            directive = _getRSTDirective(gDict)
            if directive in ['rrvnames', 'signals', 'rrgui']:  # it's one of ours!!
                """if there are other options in the docstring then they belong to this directive, we try to get them"""
                tags = _getRSTTag(gDict)
                if len(tags.values()) == 0: ## there were no tags returned, we have to take the data from the 'next' tag.
                    
                    if directive == 'rrvnames':
                        rVarNames.append(_getRvariableNames(gDict))
                    elif directive == 'signals':
                        for s in gDict.split(r'\n'):
                            signals.append(_getRRSignals(s))
                    elif directive == 'rrgui':
                        rrgui.append(_getRRGUISettings(gDict))
                else: # the docstring has some tags in it so we use those
                    if directive == 'rrvnames':
                        rVarNames.append(tags)
                    elif directive == 'signals':
                        signals.append(tags)
                    elif directive == 'rrgui':
                        rrgui.append(tags)
                        
        elif _getRSTTag(gDict) != None: # at least there are some tags so perhaps we can set these things if they are accepted.
            optionTags.update(_getRSTTag(gDict))
        else: continue
    print 'optionTags: %s' % str(optionTags)
    
    """So now we need to put all of the data into an xml file"""
    documentation = doc.createElement('documentation')
    doc.appendChild(documentation)
    
    """The name tag"""
    name = doc.createElement('name')
    documentation.appendChild(name)
    name.appendChild(doc.createTextNode(optionTags.get('Name', '')))
    """The icon tag"""
    icon = doc.createElement('icon')
    documentation.appendChild(icon)
    icon.appendChild(doc.createTextNode(optionTags.get('Icon', '')))
    """The summary tag"""
    summary = doc.createElement('summary')
    documentation.appendChild(summary)
    summary.appendChild(doc.createTextNode(optionTags.get('Summary', '')))
    """The details tag"""
    details = doc.createElement('details')
    documentation.appendChild(details)
    details.appendChild(doc.createTextNode(optionTags.get('Details', '')))
    """The tags tag"""
    tags = doc.createElement('tags')
    documentation.appendChild(tags)
    for t in [s.strip() for s in optionTags.get('Tags', '').split(',')]:
        tag = doc.createElement('tag')
        tags.appendChild(tag)
        tag.appendChild(doc.createTextNode(t))
    """The signals tag"""
    sig = doc.createElement('signals')
    documentation.appendChild(sig)
    for s in [si for si in signals if si != None]:
        if s.get('type', None) == 'input':
            input = doc.createElement('input')
            sig.appendChild(input)
            signalClass = doc.createElement('signalClass')
            input.appendChild(signalClass)
            signalClass.appendChild(doc.createTextNode(s.get('class', '')))
            name = doc.createElement('name')
            input.appendChild(name)
            name.appendChild(doc.createTextNode(s.get('name', '')))
            description = doc.createElement('description')
            input.appendChild(description)
            description.appendChild(doc.createTextNode(s.get('description', '')))
        elif s.get('type', None) == 'output':
            output = doc.createElement('output')
            sig.appendChild(output)
            signalClass = doc.createElement('signalClass')
            output.appendChild(signalClass)
            signalClass.appendChild(doc.createTextNode(s.get('class', '')))
            name = doc.createElement('name')
            output.appendChild(name)
            name.appendChild(doc.createTextNode(s.get('name', '')))
            description = doc.createElement('description')
            output.appendChild(description)
            description.appendChild(doc.createTextNode(s.get('description', '')))
    """The GUIElements tag"""
    GUIElements = doc.createElement('GUIElements')
    documentation.appendChild(GUIElements)
    for g in [g for g in rrgui if g != None]:
        display = doc.createElement('GUIElements')
        GUIElements.appendChild(display)
        name = doc.createElement('name')
        display.appendChild(name)
        name.appendChild(doc.createTextNode(g.get('label', '')))
        cla = doc.createElement('class')
        display.appendChild(cla)
        cla.appendChild(doc.createTextNode(g.get('class', '')))
        description = doc.createElement('description')
        display.appendChild(description)
        description.appendChild(doc.createTextNode(g.get('description', '')))
    #print 'The document'
    #print doc.toprettyxml()
    
def parseFile(filename, output):
    """Reads a file and parses out the relevant widget xml settings, writes to the file output an xml document representing the parsed data.  Prints success message on success."""
    fileStrings = []
    with open(filename, 'r') as f:
        myFile = f.read()

    """Pass the list of strings to the parser to extract the relevant structure"""
    import xml.dom.minidom
    doc = xml.dom.minidom.Document()
    _parsefile(myFile, doc)
    with open(output, 'w') as f:
        f.write(doc.toprettyxml())
    print 'Success for %s' % filename
    
def test():
    parseFile('/home/covingto/RedR/r-orange/libraries/base/widgets/readFile.py', 'output.xml')

test()